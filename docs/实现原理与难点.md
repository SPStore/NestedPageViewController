# NestedPageViewController实现原理与难点

## 嵌套滚动设计思路分析

在实现类似个人主页、商品详情页等复合视图结构时，业界主要有两种设计思路：

### 方案一：TableView + 横向ScrollView

**实现方式**：

- 底部容器视图是一个主TableView，包含一个header与唯一的cell
- cell上添加一个横向滚动的scrollView容器，contentSize为容器宽度 × 页数
- 在横向容器scrollView上添加各个子页面，每个子页面提供一个垂直滚动的scrollView
- 子页面的scrollView大小与cell一致，用于展示各自的内容

**技术弊端**：

1. **交互断层**：手指在头视图上往上拖拽整个tableView，当头部吸顶时，子页面不会惯性地继续往上滚动，因为根本没有触发子页面中scrollView的滚动事件
2. **状态不一致**：在第一个tab下往上滚动到头部吸顶，切到第二个tab，往下滚动直到头部不吸顶，切回第一个tab，如果记录了子页面中scrollView的滚动位置，此时滑动头部区域时，子页面中的scrollView无法接收到触摸滚动事件，除非去掉记录位置这一功能，但这正是本组件的亮点也是难点之一。

### 方案二：横向ScrollView + 垂直ScrollView

**实现方式**：

- 底部容器视图是一个横向滚动的scrollView，contentSize为容器宽度 × 页数
- 在横向scrollView上添加各个子页面，每个子页面占据容器宽度
- 每个子页面中提供一个垂直滚动的contentScrollView
- **关键点**：每个contentScrollView的contentInset.top设置为headerHeight，并在contentInset.top区域添加头部视图

**技术优势**：

1. **滚动连贯性**：无论从头部区域还是内容区域开始滚动，都能实现连贯的滚动体验
2. **状态一致性**：可以精确控制和同步各个子页面的滚动状态
3. **交互自然**：用户感知到的是一个统一的滚动视图，而非分离的组件
4. **扩展性**：更容易实现复杂的交互需求和视觉效果

### 方案选型

业界主流方案大多数是方案二，主要基于以下考量：

1. **用户体验**：方案二提供更流畅、自然的滚动体验，没有交互断层
2. **功能完备性**：方案一能实现的功能，方案二全部可以实现，反之则不然
3. **技术可行性**：方案二虽然实现复杂度较高，但解决了方案一中无法规避的核心交互问题
4. **扩展性**：方案二更容易扩展和定制，适应不同的业务需求

**最终选型**：NestedPageViewController采用方案二实现，通过精心设计的架构和复杂的状态管理，解决了嵌套滚动中的各种技术难题。

## 实现原理

NestedPageViewController的核心原理基于以下设计：

### 基本结构

1. **容器层次**：
   - 顶层是一个横向滚动的containerScrollView，用于切换不同的子页面
   - 每个子页面包含一个垂直滚动的contentScrollView
   - 头部视图（headerContentView）包含封面视图和标签栏

2. **核心设计**：
   - 每个contentScrollView的contentInset.top设置为headerHeight
   - 在每个contentScrollView中添加一个pageHeader，位置在y = -headerHeight
   - 当contentScrollView滚动时，pageHeader会随之移动，创造头部视图与内容视图联动的效果

3. **模块化架构**：
   - NestedPageViewController：主控制器，负责整体协调
   - NestedPageHeaderManager：头部管理器，处理头部视图状态
   - NestedPageChildManager：子控制器管理器，处理子控制器生命周期
   - NestedPageScrollCoordinator：滚动协调器，处理滚动逻辑和状态转换

### 滚动状态流转

1. **初始状态**：
   - contentOffset.y = -headerHeight
   - 头部完全显示，内容从头部下方开始

2. **向上滚动过程**：
   - contentOffset.y逐渐增加
   - 头部视图随着滚动逐渐向上移动
   - 内容区域逐渐占据更多屏幕空间

3. **吸顶状态**：
   - contentOffset.y = -tabHeight
   - 封面完全隐藏，标签栏吸顶
   - 此时头部视图切换父视图，固定在屏幕顶部

## 实现难点

### 1. 多个contentScrollView的同步问题

**核心难点**：

- 当有多个子控制器时，需要确保它们的滚动状态保持一致
- 切换tab时，新显示的contentScrollView需要立即匹配当前的滚动状态
- 不同contentScrollView可能有不同的内容高度和布局，需要统一协调

**解决方案**：

- 引入pin视图作为参考点，记录当前的滚动状态
- 通过pin的位置变化计算其他contentScrollView需要同步的偏移量
- 使用deltaY机制同步所有contentScrollView：

```swift
// 计算pin的位置变化
let deltaY = currentPinY - headerManager.previousPinY
headerManager.previousPinY = currentPinY

// 同步其他contentScrollView的偏移
for childViewController in childManager.viewControllerMap.values {
    let contentScrollView = childViewController.contentScrollView()
    guard contentScrollView != viewController.currentContentScrollView else {
        continue
    }
    
    var newOffset = contentScrollView.contentOffset
    newOffset.y -= deltaY
    
    // 非吸顶状态时，如果keepsContentScrollPosition为false，其余scrollView偏移量全部恢复到初始值
    if !viewController.keepsContentScrollPosition && abs(deltaY) > CGFloat.ulpOfOne {
        newOffset.y = -(currentPinY + headerManager.pageHeaderHeight)
    }
    contentScrollView.setContentOffset(newOffset, animated: false)
}
```

### 2. 头视图的父视图切换策略以及头视图的位置计算

**核心难点**：

- headerContentView需要在不同的父视图之间切换，以实现不同滚动状态下的正确行为
- 切换过程中需要保持视觉连续性，避免跳变
- 头部视图位置需要精确计算，确保滚动流畅

**解决方案**：

- 通过pin这个"外力"实现精准位置计算，避免依赖不稳定的scrollView状态
- 设计三种头部视图状态及对应的父视图：
  1. 正常滚动：headerContentView在pageHeader上，跟随内容滚动
  2. 半吸顶状态：根据触摸位置和滚动方向决定头部行为
  3. 吸顶状态：headerContentView在fixedContainer上，保持固定位置

### 3. 横向滚动与垂直滚动的协调

**核心难点**：

- 在横向切换tab的同时，需要保持垂直滚动状态的一致性
- 横向滚动过程中可能出现视觉间隙或颜色不一致
- 横向滚动结束后需要恢复正确的头部位置和滚动状态

**解决方案**：

- 在横向滚动开始时，将headerContentView转移到fixedContainer
- 使用shimView填充可能的视觉间隙，匹配背景色
- 在滚动结束后，根据当前状态恢复正确的头部位置

### 4. 回弹和减速过程中的特殊处理

**核心难点**：

- 在回弹或减速过程中切换tab，可能导致视觉跳变或状态不一致
- 回弹过程中头部视图的位置需要特殊处理
- UIView动画可能与滚动动画冲突，导致视觉异常

**解决方案**：

- 精确检测scrollView的isTopBouncing和isDecelerating状态
- 在回弹过程中保持headerContentView的连续移动
- 使用UIView.performWithoutAnimation和isWaitingForAnimationEnd标记处理动画冲突
- 在特定情况下中断减速过程：

### 5. 保持子页面中垂直scrollView的滚动位置

**核心难点**：

- 切换tab时，需要决定是否保持每个子页面的滚动位置
- 不同滚动状态下可能需要不同的行为
- 需要避免"悬挂"现象（切换tab后头部位置不一致）

**解决方案**：

- 提供keepsContentScrollPosition配置选项，允许用户控制行为
- 在非吸顶状态下，根据配置决定是否重置其他scrollView的位置
- 使用pin机制确保同步准确性，避免依赖不稳定的scrollView状态：

```swift
// 非吸顶状态时，如果keepsContentScrollPosition为false，其余scrollView偏移量全部恢复到初始值
if !viewController.keepsContentScrollPosition && abs(deltaY) > CGFloat.ulpOfOne {
    newOffset.y = -(currentPinY + headerManager.pageHeaderHeight)
}
```

## 关键技术细节

### 1. fixedContainerView

**作用**：

- 作为headerContentView在吸顶状态下的父视图
- 通过mask裁剪超出容器的部分，确保视觉效果正确
- 允许子视图交互但自身不拦截事件，解决事件传递问题

**实现**：

```swift
lazy var fixedContainer: UIView = {
    // 通过allowsSubviewHitTestOnly实现仅子视图交互，屏蔽自身交互
    let fixedContainer = NestedPageHeaderView()
    fixedContainer.allowsSubviewHitTestOnly = true
    viewController?.containerView.addSubview(fixedContainer)
    return fixedContainer
}()

// 设置mask只裁剪上边
let path = UIBezierPath(rect: fixedContainer.bounds)
// 下方留出额外空间，防止回弹过程中tab消失
let topRect = CGRect(x: 0, y: 0, width: fixedContainer.bounds.size.width, height: fixedContainer.bounds.size.height + 200)
path.append(UIBezierPath(rect: topRect))
fixedContainerLayer.path = path.cgPath
fixedContainer.layer.mask = fixedContainerLayer
```

### 2. shimView

**作用**：

- 在回弹过程中切换tab时，填充可能出现的视觉间隙
- 匹配上一个正在回弹的scrollView的背景色，确保视觉连续性
- 解决相邻tab背景色不一致时的视觉问题

### 3. Pin机制

**作用**：

- 作为参考点，控制头部视图位置和同步其他scrollView
- 在回弹和吸顶状态下保持固定，确保其他scrollView的正确行为
- 简化复杂状态下的位置计算，避免依赖不稳定的scrollView状态

**实现**：

```swift
// 设置pin视图（不可见）
func setupPin() {
    pin.isHidden = true
    viewController.containerView.addSubview(pin)
}

// 调整pin位置
func adjustPinY(_ y: CGFloat) {
    pin.frame = CGRect(x: 0, y: y, width: viewController.containerView.bounds.width, height: pageHeaderHeight)
}

// 使用pin同步其他scrollView
let deltaY = currentPinY - headerManager.previousPinY
headerManager.previousPinY = currentPinY
// 应用deltaY到其他scrollView
```

### 4. 事件处理优化

**作用**：

- 确保头部视图和内容视图都能正确接收事件
- 优化横向滚动体验，避免意外触发tab切换
- 支持半吸顶状态下的特殊交互行为

### 5. 动画冲突处理

**作用**：

- 解决UIView动画与滚动动画的冲突
- 确保在下拉刷新等场景下的视觉连续性
- 避免头部视图在动画过程中的闪跳

## 用户体验优化

### 1. 子页面中垂直scrollView减速过程中支持tab切换

**核心优化**：

- 在contentScrollView减速过程中，将headerContentView转移到fixedContainer
- 使用异步检测减速结束，恢复正确的头部位置
- 确保切换过程中的视觉连续性，提升交互流畅度

### 2. 头部悬停时的触摸区域控制

**核心优化**：

- 通过headerMovesOnlyWhenTouchingHeaderDuringHover属性提供精细控制
- 使用isHitted属性精确跟踪触摸位置
- 根据触摸位置决定头部移动行为，提升交互精准度

### 3. 惯性滚动中断控制

**核心优化**：

- 提供interruptsScrollingWhenTransitioningToFullStick属性，允许用户控制行为
- 在过渡到完全吸顶状态时，可选择中断惯性滚动
- 根据用户偏好提供不同的吸顶体验，增强可定制性

### 4. 局部下拉刷新支持

**核心优化**：

- 通过headerBounces属性控制头部是否有弹性效果
- 在headerBounces=false时，特别优化局部下拉刷新体验
- 处理下拉刷新过程中的动画冲突，确保视觉连续性

### 5. 横向滚动优化

**核心优化**：

- 禁止在头部区域的横向滚动手势，避免意外切换tab
- 在横向滚动过程中临时禁用容器视图的用户交互，防止头部视图闪烁
- 优化横向滚动过程中的视觉连续性，提升整体体验

### 6. 子VC中有2个scrollView的情况
类似美团、饿了吗的商品点餐页，在第一个tab下的子VC中有2个scrollView，左边是分类，右边是列表，我给出一个实现思路（针对第一个子VC）：
最底部必然是有一个容器scrollView（作为本框架中NestedPageScrollable协议里的的nestedPageContentScrollView），其上面添加了2个子scrollView，y值均为0即可，因为本框架会自动设置容器scrollView的contentInset.top和contentOffset.y，2个子scrollVIew会自动显示在tab栏的下方。2个子scrollView禁用滚动，只处理容器scrollView的滚动即可。

3个scrollView大致层级+约束关系如下：

View (Controller.view)
│
└── containerScrollView (UIScrollView)
    │  edges = view.edges
    │
    └── contentView (UIView)
        │  edges = containerScrollView.contentLayoutGuide.edges
        │  width = containerScrollView.frameLayoutGuide.width
        │
        ├── leftScrollView (UITableView/UICollectionView)
        │   top = contentView.top
        │   bottom = contentView.bottom
        │   leading = contentView.leading
        │   width = 30% screen width
        │
        └── rightScrollView (UITableView/UICollectionView)
            top = contentView.top
            bottom = contentView.bottom
            leading = leftTableView.trailing
            trailing = contentView.trailing
            width = 70% screen width

leftScrollView和rightScrollView需要自定义UITableView/UICollectionView的子类，重写intrinsicContentSize返回leftScrollView/rightScrollView的contentSize，目的是为了能够将容器scroollView撑起。或者不用子类，那就自己手动计算containerScrollView的contentSize

 由于时间问题，该示例没有完成，以后有机会再尝试尝试。

## 总结

NestedPageViewController采用业界主流的方案二设计思路，通过精心设计的架构和复杂的状态管理，成功实现了流畅的嵌套滚动效果。其核心原理是通过设置contentInset和在负坐标位置放置头部视图，创造出头部视图看似是contentScrollView一部分的错觉。

通过解决多个contentScrollView同步、头部视图父视图切换、横向与垂直滚动协调、回弹和减速处理、保持滚动位置等一系列技术难点，NestedPageViewController提供了流畅的用户体验和灵活的配置选项。

细节处理如fixedContainerView、shimView、pin机制等，以及用户体验优化如减速过程中tab切换支持、头部悬停触摸控制等，使NestedPageViewController成为一个功能完善、体验优秀的嵌套滚动解决方案，能够满足各种复杂的业务场景需求。
